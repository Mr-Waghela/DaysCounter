<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>#Daag</title>
    <style>
        body {
            background: #0C0C0C
        }

        .time {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 270px;
            background: #f2709c;  /* fallback for old browsers */
            background: -webkit-linear-gradient(to right, #ff9472, #f2709c);  /* Chrome 10-25, Safari 5.1-6 */
            background: linear-gradient(to right, #ff9472, #f2709c); /* W3C, IE 10+/ Edge, Firefox 16+, Chrome 26+, Opera 12+, Safari 7+ */

            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            font-size: clamp(2rem, -0.107rem + 4.286vw, 3.75rem);
            font-weight: bold;
            text-transform: uppercase;
        }
    </style>
</head>
<body>
    <div class="time"></div>
    <script>
        // ============================
        // Configuration Variables
        // ============================
        const CONFIG = {
            targetDate: '2026-02-03T00:00:00Z', // Target date for the timer
            timerElementsClass: '.time',        // CSS class for timer display elements
            timeUpMessage: "Happy Marraige day Love!!!!",        // Message when the timer hits zero
            leadingZeros: true                // Add leading zeros to time units
        };

        // ============================
        // Helper Functions
        // ============================

        // Function to format time with or without leading zeros
        function formatTime(unit) {
            return CONFIG.leadingZeros ? (unit < 10 ? "0" + unit : unit) : unit;
        }

        // Function to update the time display
        function updateTime(timer, display) {
            const SECONDS_IN_DAY = 86400;
            const SECONDS_IN_HOUR = 3600;
            const SECONDS_IN_MINUTE = 60;

            const days = Math.floor(timer / SECONDS_IN_DAY);
            const hours = Math.floor((timer % SECONDS_IN_DAY) / SECONDS_IN_HOUR);
            const minutes = Math.floor((timer % SECONDS_IN_HOUR) / SECONDS_IN_MINUTE);
            const seconds = Math.floor(timer % SECONDS_IN_MINUTE);

            // Build the time string
            const timeString = `${formatTime(days)}d ${formatTime(hours)}h ${formatTime(minutes)}m ${formatTime(seconds)}s`;

            // Update each display element
            display.forEach(el => el.textContent = timeString);
        }

        // Function to start the countdown timer
        function startTimer(duration, display) {
            let timer = duration;

            // Initial display
            updateTime(timer, display);

            const intervalID = setInterval(() => {
                if (timer <= 0) {
                    clearInterval(intervalID);
                    display.forEach(el => el.textContent = CONFIG.timeUpMessage);
                } else {
                    timer--;
                    updateTime(timer, display);
                }
            }, 1000);
        }

        // Function to calculate seconds until a target date
        function getTimeUntilTarget(targetDate) {
            const now = Date.now();
            const target = new Date(targetDate).getTime();
            return Math.max(Math.floor((target - now) / 1000), 0); // Ensure non-negative duration
        }

        // ============================
        // Main Script
        // ============================
        window.onload = function () {
            const displayElements = document.querySelectorAll(CONFIG.timerElementsClass);
            if (displayElements.length > 0) {
                const duration = getTimeUntilTarget(CONFIG.targetDate);
                startTimer(duration, displayElements);
            }
        };

        class Progress {
                constructor(param = {}) {
                    this.timestamp = null;
                    this.duration = param.duration || Progress.CONST.DURATION;
                    this.progress = 0;
                    this.delta = 0;
                    this.isLoop = !!param.isLoop;

                    this.reset();
                }

                static get CONST() {
                    return {
                        DURATION: 1000
                    };
                }

                reset() {
                    this.timestamp = null;
                }

                start(now) {
                    this.timestamp = now;
                }

                tick(now) {
                    if (this.timestamp) {
                        this.delta = now - this.timestamp;
                        this.progress = Math.min(this.delta / this.duration, 1);

                        if (this.progress >= 1 && this.isLoop) {
                            this.start(now);
                        }

                        return this.progress;
                    } else {
                        return 0;
                    }
                }
            }

            class Confetti {
                constructor(param) {
                    this.parent = param.elm || document.body;
                    this.canvas = document.createElement("canvas");
                    this.ctx = this.canvas.getContext("2d");
                    this.width = param.width || this.parent.offsetWidth;
                    this.height = param.height || this.parent.offsetHeight;
                    this.length = param.length || Confetti.CONST.PAPER_LENGTH;
                    this.yRange = param.yRange || this.height * 2;
                    this.progress = new Progress({
                        duration: param.duration,
                        isLoop: true
                    });
                    this.rotationRange = typeof param.rotationRange === "number" ? param.rotationRange
                        : 10;
                    this.speedRange = typeof param.speedRange === "number" ? param.speedRange
                        : 10;
                    this.sprites = [];

                    this.canvas.style.cssText = [
                        "display: block",
                        "position: absolute",
                        "top: 0",
                        "left: 0",
                        "pointer-events: none"
                    ].join(";");

                    this.render = this.render.bind(this);

                    this.build();

                    this.parent.appendChild(this.canvas);
                    this.progress.start(performance.now());

                    requestAnimationFrame(this.render);
                }

                static get CONST() {
                    return {
                        SPRITE_WIDTH: 9,
                        SPRITE_HEIGHT: 16,
                        PAPER_LENGTH: 100,
                        DURATION: 8000,
                        ROTATION_RATE: 50,
                        COLORS: [
                            "#EF5350",
                            "#EC407A",
                            "#AB47BC",
                            "#7E57C2",
                            "#5C6BC0",
                            "#42A5F5",
                            "#29B6F6",
                            "#26C6DA",
                            "#26A69A",
                            "#66BB6A",
                            "#9CCC65",
                            "#D4E157",
                            "#FFEE58",
                            "#FFCA28",
                            "#FFA726",
                            "#FF7043",
                            "#8D6E63",
                            "#BDBDBD",
                            "#78909C"
                        ]
                    };
                }

                build() {
                    for (let i = 0; i < this.length; ++i) {
                        let canvas = document.createElement("canvas"),
                            ctx = canvas.getContext("2d");

                        canvas.width = Confetti.CONST.SPRITE_WIDTH;
                        canvas.height = Confetti.CONST.SPRITE_HEIGHT;

                        canvas.position = {
                            initX: Math.random() * this.width,
                            initY: -canvas.height - Math.random() * this.yRange
                        };

                        canvas.rotation = (this.rotationRange / 2) - Math.random() * this.rotationRange;
                        canvas.speed = (this.speedRange / 2) + Math.random() * (this.speedRange / 2);

                        ctx.save();
                        ctx.fillStyle = Confetti.CONST.COLORS[(Math.random() * Confetti.CONST.COLORS.length) | 0];
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        ctx.restore();

                        this.sprites.push(canvas);
                    }
                }

                render(now) {
                    let progress = this.progress.tick(now);

                    this.canvas.width = this.width;
                    this.canvas.height = this.height;

                    for (let i = 0; i < this.length; ++i) {
                        this.ctx.save();
                        this.ctx.translate(
                            this.sprites[i].position.initX + this.sprites[i].rotation * Confetti.CONST.ROTATION_RATE * progress,
                            this.sprites[i].position.initY + progress * (this.height + this.yRange)
                        );
                        this.ctx.rotate(this.sprites[i].rotation);
                        this.ctx.drawImage(
                            this.sprites[i],
                            -Confetti.CONST.SPRITE_WIDTH * Math.abs(Math.sin(progress * Math.PI * 2 * this.sprites[i].speed)) / 2,
                            -Confetti.CONST.SPRITE_HEIGHT / 2,
                            Confetti.CONST.SPRITE_WIDTH * Math.abs(Math.sin(progress * Math.PI * 2 * this.sprites[i].speed)),
                            Confetti.CONST.SPRITE_HEIGHT
                        );
                        this.ctx.restore();
                    }

                    requestAnimationFrame(this.render);
                }
            }

            (() => {
                const DURATION = 8000,
                    LENGTH = 120;

                new Confetti({
                    width: window.innerWidth,
                    height: window.innerHeight,
                    length: LENGTH,
                    duration: DURATION
                });

                setTimeout(() => {
                    new Confetti({
                        width: window.innerWidth,
                        height: window.innerHeight,
                        length: LENGTH,
                        duration: DURATION
                    });
                }, DURATION / 2);
            })();

    </script>
</body>
</html>